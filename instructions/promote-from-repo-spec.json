{
  "id": "promote-from-repo-spec",
  "title": "Implementation Spec: promote_from_repo Tool for mcp-index-server",
  "body": "# promote_from_repo — Implementation Specification\n\n## Overview\n\nAdd a new `promote_from_repo` tool to mcp-index-server that scans a local Git repository for promotable knowledge content (constitutions, docs, instructions, specs) and upserts them into the instruction catalog. This replaces per-repo promotion logic (like mcp-agent-manager's `indexPromoter.ts`) with a single server-side tool that any repo can use.\n\n## Motivation\n\nCurrently each repo must implement its own promotion pipeline (hash tracking, entry building, dispatch calls). By moving this to the index server:\n- New repos get promotion for free — no per-repo code needed\n- The server controls schema compliance, validation, and dedup centrally\n- Promotion logic stays in sync as the instruction schema evolves\n- Repos only need a `promotion-map.json` file (convention over code)\n\n## Tool Contract\n\n### Name\n`promote_from_repo`\n\n### Classification\n- **Mutation:** yes (writes instruction files)\n- **Stable:** no\n\n### Input Schema (Zod)\n```typescript\nz.object({\n  repoPath: z.string().describe('Absolute path to the Git repository root'),\n  scope: z.enum(['all', 'governance', 'specs', 'docs', 'instructions']).default('all').describe('Which content categories to promote'),\n  force: z.boolean().default(false).describe('Re-promote even if content hash unchanged'),\n  dryRun: z.boolean().default(false).describe('Preview what would be promoted without writing'),\n  repoId: z.string().optional().describe('Override repo identifier used in category tags. Defaults to directory name of repoPath'),\n})\n```\n\n### Output\n```typescript\ninterface PromoteFromRepoResult {\n  repoPath: string;\n  repoId: string;\n  promoted: string[];        // instruction IDs that were written/updated\n  skipped: string[];         // instruction IDs skipped (unchanged hash)\n  failed: Array<{ id: string; error: string }>;\n  dryRunEntries?: Array<{ id: string; title: string; action: 'add' | 'update' | 'skip' }>;\n  total: number;\n  promotedAt: string;        // ISO 8601\n}\n```\n\n## Content Discovery\n\nThe tool scans the repo in this order:\n\n### 1. Promotion Map (primary)\nLook for `.specify/config/promotion-map.json` in the repo. If found, it defines explicit source→instruction mappings:\n\n```json\n{\n  \"description\": \"...\",\n  \"sources\": [\n    {\n      \"path\": \"constitution.json\",\n      \"instructionId\": \"my-repo-constitution\",\n      \"title\": \"My Repo Constitution\",\n      \"category\": \"governance\",\n      \"priority\": 5,\n      \"requirement\": \"mandatory\",\n      \"contentType\": \"instruction\",\n      \"classification\": \"internal\"\n    }\n  ]\n}\n```\n\nEach `sources[]` entry has:\n| Field | Type | Required | Description |\n|---|---|---|---|\n| path | string | yes | Relative path from repo root to the content file |\n| instructionId | string | yes | ID for the instruction entry (must match `^[a-z0-9][a-z0-9-_]{0,118}[a-z0-9]$`) |\n| title | string | yes | Human-readable title |\n| category | string | yes | Primary category (lowercase) |\n| priority | number | yes | 1-100 |\n| requirement | string | yes | mandatory / critical / recommended / optional |\n| contentType | string | yes | instruction / template / reference / example |\n| classification | string | yes | public / internal / restricted |\n\n### 2. Instruction Files (automatic)\nScan `instructions/*.json` in the repo root. Each file that is a valid instruction JSON (has `id`, `title`, `body`) is promoted as-is — no mapping needed. The tool must:\n- Validate each against the instruction schema\n- Skip files starting with `_` (manifests, metadata)\n- Use the file's own `id` field as the instruction ID\n\n### 3. Convention-Based Discovery (optional enhancement)\nIf no promotion-map.json exists, the tool MAY auto-discover:\n- `constitution.json` → id: `{repoId}-constitution`, category: `governance`\n- `docs/*.md` → id: `{repoId}-{filename}`, category: `architecture`\n- `.github/copilot-instructions.md` → id: `{repoId}-copilot-instructions`, category: `coding-standards`\n\nThis is a nice-to-have for v2. For v1, require either promotion-map.json or instructions/*.json.\n\n## Scope Filtering\n\nThe `scope` parameter filters which sources to process:\n\n| Scope | Categories Included |\n|---|---|\n| governance | governance, constitution, coding-standards |\n| docs | architecture, onboarding |\n| specs | spec |\n| instructions | bootstrap, speckit, runbook, instruction |\n| all | No filter — process everything |\n\nApply scope filter to the `category` field of each promotion-map source. For instruction/*.json files, check `primaryCategory` or first entry in `categories[]`.\n\n## Content Hashing & Dedup\n\nThe tool uses SHA-256 content hashing to avoid redundant writes:\n\n1. For each source file, compute `sha256(fileContents)`\n2. Check if instruction already exists in catalog via `catalogContext.getById(id)`\n3. Compare the existing entry's `sourceHash` field against computed hash\n4. If hashes match and `force` is false → skip\n5. If hashes differ or entry doesn't exist → write/overwrite\n\nThis eliminates the need for external tracking state. The `sourceHash` field already on `InstructionEntry` serves as the dedup key.\n\n## Entry Building\n\nFor promotion-map sources (non-instruction files), build the entry as:\n\n```typescript\nfunction buildEntry(source: PromotionSource, content: string, repoId: string): InstructionEntry {\n  const now = new Date().toISOString();\n  return {\n    id: source.instructionId,\n    title: source.title,\n    body: content,\n    priority: source.priority,\n    audience: 'all',\n    requirement: source.requirement as RequirementLevel,\n    categories: [source.category, repoId],\n    primaryCategory: source.category,\n    contentType: source.contentType as ContentType,\n    sourceHash: sha256(content),\n    schemaVersion: '3',\n    version: '1.0.0',\n    status: 'approved',\n    owner: 'promote_from_repo',\n    classification: source.classification,\n    semanticSummary: `${source.title} — promoted from ${repoId} repository`,\n    sourceWorkspace: repoId,\n    createdByAgent: 'promote_from_repo',\n    createdAt: now,\n    updatedAt: now,\n  };\n}\n```\n\nFor instruction/*.json files, read the JSON and:\n- Ensure `sourceHash` is set to `sha256(rawFileContents)`\n- Ensure `schemaVersion` is `'3'`\n- Add `sourceWorkspace: repoId` and `createdByAgent: 'promote_from_repo'` if not already set\n- Set `updatedAt` to now\n- Validate against instruction schema before writing\n\n## Implementation Files\n\nFollowing mcp-index-server's existing patterns:\n\n### 1. `src/services/handlers.promote.ts` (NEW)\n\nThe handler module. Approximately 250-350 lines.\n\n```typescript\nimport { createHash } from 'node:crypto';\nimport { existsSync, readFileSync, readdirSync } from 'node:fs';\nimport { join, basename } from 'node:path';\nimport { registerHandler } from '../server/registry.js';\nimport { getById, ensureLoaded, writeEntry, touchCatalogVersion } from './catalogContext.js';\nimport { CatalogLoader } from './catalogLoader.js';\nimport { logger } from '<existing-logger-path>';\n\n// Types: PromotionMap, PromotionSource, PromoteFromRepoResult (as defined above)\n\n// SCOPE_CATEGORIES map (as defined above)\n\n// sha256 helper\n\n// loadPromotionMap(repoPath: string): PromotionMap | null\n//   Read .specify/config/promotion-map.json from the repo\n\n// scanMappedSources(repoPath, map, scope): ScanResult[]\n//   Iterate map.sources, filter by scope, read files, compute hashes\n\n// scanInstructionFiles(repoPath): ScanResult[]\n//   Read instructions/*.json, parse, build ScanResult for each valid file\n\n// buildEntry(source, content, repoId): InstructionEntry\n//   As defined above\n\nregisterHandler('promote_from_repo', async (params) => {\n  // 1. Validate repoPath exists and is a directory\n  // 2. Derive repoId from params.repoId || basename(repoPath)\n  // 3. Load promotion map (optional — proceed with just instructions/ if missing)\n  // 4. Scan sources based on scope\n  // 5. Also scan instructions/*.json if scope is 'all' or 'instructions'\n  // 6. Dedup loop: for each source, check catalog hash, build entry, write or skip\n  // 7. Return PromoteFromRepoResult\n});\n```\n\n### 2. `src/services/toolRegistry.ts` (MODIFY)\n\nAdd to `INPUT_SCHEMAS`:\n```typescript\npromote_from_repo: {\n  type: 'object',\n  properties: {\n    repoPath: { type: 'string', description: 'Absolute path to the Git repository root' },\n    scope: { type: 'string', enum: ['all', 'governance', 'specs', 'docs', 'instructions'], default: 'all' },\n    force: { type: 'boolean', default: false },\n    dryRun: { type: 'boolean', default: false },\n    repoId: { type: 'string', description: 'Override repo identifier. Defaults to directory name.' },\n  },\n  required: ['repoPath'],\n}\n```\n\nAdd `'promote_from_repo'` to the `MUTATION` set.\n\nAdd description in `describeTool()`:\n```typescript\ncase 'promote_from_repo':\n  return 'Scan a local Git repository and promote its knowledge content (constitutions, docs, instructions, specs) into the instruction catalog. Reads .specify/config/promotion-map.json and instructions/*.json from the target repo.';\n```\n\n### 3. `src/services/toolHandlers.ts` (MODIFY)\n\nAdd side-effect import:\n```typescript\nimport './handlers.promote';\n```\n\n### 4. `src/services/toolRegistry.zod.ts` (MODIFY)\n\nAdd Zod schema variant if this file maintains parallel Zod definitions.\n\n### 5. Test File: `src/tests/promote-from-repo.test.ts` (NEW)\n\nTest cases:\n- **promote with promotion-map.json** — creates temp repo with map + files, promotes, verifies entries in catalog\n- **promote instructions/*.json** — creates temp repo with instruction JSONs, promotes as-is\n- **scope filtering** — only promotes matching categories\n- **content hash dedup** — promotes once, second call skips unchanged, modifies file, third call promotes again\n- **force flag** — promotes even when hash matches\n- **dryRun** — returns preview without writing\n- **missing repo path** — returns error\n- **empty repo** — returns zero total with no errors\n- **malformed files** — skips invalid JSONs, reports in failed[]\n- **repoId override** — uses custom repoId in categories and sourceWorkspace\n\n## Integration with Existing Systems\n\n### Catalog Loader\nPromoted entries are written via `writeEntry()` to `instructions/{id}.json`. The catalog loader picks them up on next reload. Use `touchCatalogVersion()` after batch write to trigger cross-process invalidation.\n\n### Bootstrap Gating\nThe tool performs mutations but should be allowed even without `MCP_ENABLE_MUTATION` if accessed through the handler registry (same pattern as `instructions_dispatch` using `_viaDispatcher: true`). Alternatively, add `promote_from_repo` to the bootstrap allowlist.\n\n### Audit Log\nEmit audit entries for each promoted/updated instruction:\n```typescript\nauditLog.append({\n  action: 'promote_from_repo',\n  instructionId: entry.id,\n  repoPath: params.repoPath,\n  repoId,\n  result: 'promoted' | 'skipped' | 'failed',\n});\n```\n\n### Schema Validation\nAll entries MUST pass JSON Schema validation (`schemas/instruction.schema.json`) before being written. Use the existing `CatalogLoader` or `ClassificationService.validate()` for this. Reject entries that fail validation with a clear error message in the `failed[]` array.\n\n## Migration Path\n\nOnce this tool is deployed:\n\n1. **Immediate:** Repos can call `promote_from_repo` via MCP instead of implementing their own promotion code\n2. **Short-term:** Remove `indexPromoter.ts` and `mgr_promote_knowledge` tool from mcp-agent-manager\n3. **Long-term:** Add convention-based discovery (v2) so repos don't even need promotion-map.json\n\n## Security Considerations\n\n- `repoPath` must be validated as an existing directory\n- Consider restricting to paths under known workspace roots (optional, configurable)\n- File reads are local only — no network operations to the repo\n- The tool writes to the instructions/ directory, same as any other mutation\n- Rate limiting: use existing handler timing/throttle infrastructure\n\n## Error Handling\n\n- If `repoPath` doesn't exist or isn't a directory → return error response, don't throw\n- If promotion-map.json is malformed → log warning, fall back to instructions/ only\n- If a source file in the map is missing → skip with debug log, don't fail the whole batch\n- If schema validation fails for an entry → add to `failed[]` with validation error message\n- If `writeEntry()` fails (disk error) → add to `failed[]`, continue with remaining entries",
  "priority": 10,
  "audience": "all",
  "requirement": "critical",
  "categories": [
    "spec",
    "promotion",
    "mcp-index-server",
    "implementation"
  ],
  "primaryCategory": "spec",
  "contentType": "instruction",
  "sourceHash": "622b78d796197d74f6d2dc65cef44a94e80ce062b389e678971d7ff702747032",
  "schemaVersion": "3",
  "version": "1.0.0",
  "status": "approved",
  "owner": "system",
  "classification": "internal",
  "semanticSummary": "Detailed implementation specification for adding a promote_from_repo tool to mcp-index-server that scans local Git repositories and upserts their knowledge content into the instruction catalog",
  "createdAt": "2025-07-25T00:00:00Z",
  "updatedAt": "2025-07-25T00:00:00Z",
  "createdByAgent": "copilot",
  "sourceWorkspace": "mcp-agent-manager"
}
